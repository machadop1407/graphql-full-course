'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const tslib = require('tslib');
const utils = require('@graphql-tools/utils/es5');
const process = require('process');
const graphql = require('graphql');
const pLimit = _interopDefault(require('p-limit'));
const module$1 = require('module');
const path = require('path');
const schema = require('@graphql-tools/schema/es5');

function normalizePointers(unnormalizedPointerOrPointers) {
    var e_1, _a, e_2, _b;
    var ignore = [];
    var pointerOptionMap = {};
    var handlePointer = function (rawPointer, options) {
        if (options === void 0) { options = {}; }
        if (rawPointer.startsWith('!')) {
            ignore.push(rawPointer.replace('!', ''));
        }
        else {
            pointerOptionMap[rawPointer] = options;
        }
    };
    try {
        for (var _c = tslib.__values(utils.asArray(unnormalizedPointerOrPointers)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var rawPointer = _d.value;
            if (typeof rawPointer === 'string') {
                handlePointer(rawPointer);
            }
            else if (typeof rawPointer === 'object') {
                try {
                    for (var _e = (e_2 = void 0, tslib.__values(Object.entries(rawPointer))), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var _g = tslib.__read(_f.value, 2), path = _g[0], options = _g[1];
                        handlePointer(path, options);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else {
                throw new Error("Invalid pointer '" + rawPointer + "'.");
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { ignore: ignore, pointerOptionMap: pointerOptionMap };
}

function applyDefaultOptions(options) {
    options.cache = options.cache || {};
    options.cwd = options.cwd || process.cwd();
    options.sort = 'sort' in options ? options.sort : true;
}

function loadFile(pointer, options) {
    var _a;
    return tslib.__awaiter(this, void 0, void 0, function () {
        var results, errors_1;
        var _this = this;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    results = (_a = options.cache) === null || _a === void 0 ? void 0 : _a[pointer];
                    if (!!results) return [3 /*break*/, 2];
                    results = [];
                    errors_1 = [];
                    return [4 /*yield*/, Promise.all(options.loaders.map(function (loader) { return tslib.__awaiter(_this, void 0, void 0, function () {
                            var loaderResults, error_1, _a, _b, errorElement;
                            var e_1, _c;
                            return tslib.__generator(this, function (_d) {
                                switch (_d.label) {
                                    case 0:
                                        _d.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, loader.load(pointer, options)];
                                    case 1:
                                        loaderResults = _d.sent();
                                        loaderResults === null || loaderResults === void 0 ? void 0 : loaderResults.forEach(function (result) { return results.push(result); });
                                        return [3 /*break*/, 3];
                                    case 2:
                                        error_1 = _d.sent();
                                        if (process.env['DEBUG']) {
                                            console.error(error_1);
                                        }
                                        if (error_1 instanceof utils.AggregateError) {
                                            try {
                                                for (_a = tslib.__values(error_1.errors), _b = _a.next(); !_b.done; _b = _a.next()) {
                                                    errorElement = _b.value;
                                                    errors_1.push(errorElement);
                                                }
                                            }
                                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                            finally {
                                                try {
                                                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                                                }
                                                finally { if (e_1) throw e_1.error; }
                                            }
                                        }
                                        else {
                                            errors_1.push(error_1);
                                        }
                                        return [3 /*break*/, 3];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _b.sent();
                    if (results.length === 0 && errors_1.length > 0) {
                        if (errors_1.length === 1) {
                            throw errors_1[0];
                        }
                        throw new utils.AggregateError(errors_1, "Failed to find any GraphQL type definitions in: " + pointer + ";\n - " + errors_1
                            .map(function (error) { return error.message; })
                            .join('\n  - '));
                    }
                    if (options.cache) {
                        options.cache[pointer] = results;
                    }
                    _b.label = 2;
                case 2: return [2 /*return*/, results];
            }
        });
    });
}
function loadFileSync(pointer, options) {
    var e_2, _a, e_3, _b;
    var _c;
    var results = (_c = options.cache) === null || _c === void 0 ? void 0 : _c[pointer];
    if (!results) {
        results = [];
        var errors = [];
        try {
            for (var _d = tslib.__values(options.loaders), _e = _d.next(); !_e.done; _e = _d.next()) {
                var loader = _e.value;
                try {
                    // We check for the existence so it is okay to force non null
                    var loaderResults = loader.loadSync(pointer, options);
                    loaderResults === null || loaderResults === void 0 ? void 0 : loaderResults.forEach(function (result) { return results.push(result); });
                }
                catch (error) {
                    if (process.env['DEBUG']) {
                        console.error(error);
                    }
                    if (error instanceof utils.AggregateError) {
                        try {
                            for (var _f = (e_3 = void 0, tslib.__values(error.errors)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var errorElement = _g.value;
                                errors.push(errorElement);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                    else {
                        errors.push(error);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (results.length === 0 && errors.length > 0) {
            if (errors.length === 1) {
                throw errors[0];
            }
            throw new utils.AggregateError(errors, "Failed to find any GraphQL type definitions in: " + pointer + ";\n - " + errors
                .map(function (error) { return error.message; })
                .join('\n  - '));
        }
        if (options.cache) {
            options.cache[pointer] = results;
        }
    }
    return results;
}

/**
 * Converts a string to 32bit integer
 */
function stringToHash(str) {
    var hash = 0;
    if (str.length === 0) {
        return hash;
    }
    var char;
    for (var i = 0; i < str.length; i++) {
        char = str.charCodeAt(i);
        // tslint:disable-next-line: no-bitwise
        hash = (hash << 5) - hash + char;
        // tslint:disable-next-line: no-bitwise
        hash = hash & hash;
    }
    return hash;
}
function useStack() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (input) {
        function createNext(i) {
            if (i >= fns.length) {
                return function () { };
            }
            return function next() {
                fns[i](input, createNext(i + 1));
            };
        }
        fns[0](input, createNext(1));
    };
}
function useLimit(concurrency) {
    return pLimit(concurrency);
}

function getCustomLoaderByPath(path$1, cwd) {
    try {
        var requireFn = module$1.createRequire(path.join(cwd, 'noop.js'));
        var requiredModule = requireFn(path$1);
        if (requiredModule) {
            if (requiredModule.default && typeof requiredModule.default === 'function') {
                return requiredModule.default;
            }
            if (typeof requiredModule === 'function') {
                return requiredModule;
            }
        }
    }
    catch (e) { }
    return null;
}
function useCustomLoader(loaderPointer, cwd) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var loader;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(typeof loaderPointer === 'string')) return [3 /*break*/, 2];
                    return [4 /*yield*/, getCustomLoaderByPath(loaderPointer, cwd)];
                case 1:
                    loader = _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    if (typeof loaderPointer === 'function') {
                        loader = loaderPointer;
                    }
                    _a.label = 3;
                case 3:
                    if (typeof loader !== 'function') {
                        throw new Error("Failed to load custom loader: " + loaderPointer);
                    }
                    return [2 /*return*/, loader];
            }
        });
    });
}
function useCustomLoaderSync(loaderPointer, cwd) {
    var loader;
    if (typeof loaderPointer === 'string') {
        loader = getCustomLoaderByPath(loaderPointer, cwd);
    }
    else if (typeof loaderPointer === 'function') {
        loader = loaderPointer;
    }
    if (typeof loader !== 'function') {
        throw new Error("Failed to load custom loader: " + loaderPointer);
    }
    return loader;
}

function useQueue(options) {
    var _this = this;
    var queue = [];
    var limit = (options === null || options === void 0 ? void 0 : options.concurrency) ? pLimit(options.concurrency) : function (fn) { return tslib.__awaiter(_this, void 0, void 0, function () { return tslib.__generator(this, function (_a) {
        return [2 /*return*/, fn()];
    }); }); };
    return {
        add: function (fn) {
            queue.push(function () { return limit(fn); });
        },
        runAll: function () {
            return Promise.all(queue.map(function (fn) { return fn(); }));
        },
    };
}
function useSyncQueue() {
    var queue = [];
    return {
        add: function (fn) {
            queue.push(fn);
        },
        runAll: function () {
            var e_1, _a;
            try {
                for (var queue_1 = tslib.__values(queue), queue_1_1 = queue_1.next(); !queue_1_1.done; queue_1_1 = queue_1.next()) {
                    var fn = queue_1_1.value;
                    fn();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (queue_1_1 && !queue_1_1.done && (_a = queue_1.return)) _a.call(queue_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        },
    };
}

var CONCURRENCY_LIMIT = 50;
function collectSources(_a) {
    var pointerOptionMap = _a.pointerOptionMap, options = _a.options;
    return tslib.__awaiter(this, void 0, void 0, function () {
        var sources, queue, _b, addSource, collect, pointer, pointerOptions;
        return tslib.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    sources = [];
                    queue = useQueue({ concurrency: CONCURRENCY_LIMIT });
                    _b = createHelpers({
                        sources: sources,
                        stack: [collectDocumentString, collectCustomLoader, collectFallback],
                    }), addSource = _b.addSource, collect = _b.collect;
                    for (pointer in pointerOptionMap) {
                        pointerOptions = pointerOptionMap[pointer];
                        collect({
                            pointer: pointer,
                            pointerOptions: pointerOptions,
                            pointerOptionMap: pointerOptionMap,
                            options: options,
                            addSource: addSource,
                            queue: queue.add,
                        });
                    }
                    return [4 /*yield*/, queue.runAll()];
                case 1:
                    _c.sent();
                    return [2 /*return*/, sources];
            }
        });
    });
}
function collectSourcesSync(_a) {
    var pointerOptionMap = _a.pointerOptionMap, options = _a.options;
    var sources = [];
    var queue = useSyncQueue();
    var _b = createHelpers({
        sources: sources,
        stack: [collectDocumentString, collectCustomLoaderSync, collectFallbackSync],
    }), addSource = _b.addSource, collect = _b.collect;
    for (var pointer in pointerOptionMap) {
        var pointerOptions = pointerOptionMap[pointer];
        collect({
            pointer: pointer,
            pointerOptions: pointerOptions,
            pointerOptionMap: pointerOptionMap,
            options: options,
            addSource: addSource,
            queue: queue.add,
        });
    }
    queue.runAll();
    return sources;
}
function createHelpers(_a) {
    var sources = _a.sources, stack = _a.stack;
    var addSource = function (_a) {
        var source = _a.source;
        sources.push(source);
    };
    var collect = useStack.apply(void 0, tslib.__spreadArray([], tslib.__read(stack), false));
    return {
        addSource: addSource,
        collect: collect,
    };
}
function addResultOfCustomLoader(_a) {
    var pointer = _a.pointer, result = _a.result, addSource = _a.addSource;
    if (graphql.isSchema(result)) {
        addSource({
            source: {
                location: pointer,
                schema: result,
                document: utils.getDocumentNodeFromSchema(result),
            },
            pointer: pointer,
            noCache: true,
        });
    }
    else if (result.kind && result.kind === graphql.Kind.DOCUMENT) {
        addSource({
            source: {
                document: result,
                location: pointer,
            },
            pointer: pointer,
        });
    }
    else if (result.document) {
        addSource({
            source: tslib.__assign({ location: pointer }, result),
            pointer: pointer,
        });
    }
}
function collectDocumentString(_a, next) {
    var pointer = _a.pointer, pointerOptions = _a.pointerOptions, options = _a.options, addSource = _a.addSource, queue = _a.queue;
    if (utils.isDocumentString(pointer)) {
        return queue(function () {
            var source = utils.parseGraphQLSDL(stringToHash(pointer) + ".graphql", pointer, tslib.__assign(tslib.__assign({}, options), pointerOptions));
            addSource({
                source: source,
                pointer: pointer,
            });
        });
    }
    next();
}
function collectCustomLoader(_a, next) {
    var _this = this;
    var pointer = _a.pointer, pointerOptions = _a.pointerOptions, queue = _a.queue, addSource = _a.addSource, options = _a.options, pointerOptionMap = _a.pointerOptionMap;
    if (pointerOptions.loader) {
        return queue(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
            var loader, result;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, useCustomLoader(pointerOptions.loader, options.cwd)];
                    case 1:
                        loader = _a.sent();
                        return [4 /*yield*/, loader(pointer, tslib.__assign(tslib.__assign({}, options), pointerOptions), pointerOptionMap)];
                    case 2:
                        result = _a.sent();
                        if (!result) {
                            return [2 /*return*/];
                        }
                        addResultOfCustomLoader({ pointer: pointer, result: result, addSource: addSource });
                        return [2 /*return*/];
                }
            });
        }); });
    }
    next();
}
function collectCustomLoaderSync(_a, next) {
    var pointer = _a.pointer, pointerOptions = _a.pointerOptions, queue = _a.queue, addSource = _a.addSource, options = _a.options, pointerOptionMap = _a.pointerOptionMap;
    if (pointerOptions.loader) {
        return queue(function () {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore TODO options.cwd is possibly undefined, but it seems like no test covers this path
            var loader = useCustomLoaderSync(pointerOptions.loader, options.cwd);
            var result = loader(pointer, tslib.__assign(tslib.__assign({}, options), pointerOptions), pointerOptionMap);
            if (result) {
                addResultOfCustomLoader({ pointer: pointer, result: result, addSource: addSource });
            }
        });
    }
    next();
}
function collectFallback(_a) {
    var _this = this;
    var queue = _a.queue, pointer = _a.pointer, options = _a.options, pointerOptions = _a.pointerOptions, addSource = _a.addSource;
    return queue(function () { return tslib.__awaiter(_this, void 0, void 0, function () {
        var sources, sources_1, sources_1_1, source;
        var e_1, _a;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadFile(pointer, tslib.__assign(tslib.__assign({}, options), pointerOptions))];
                case 1:
                    sources = _b.sent();
                    if (sources) {
                        try {
                            for (sources_1 = tslib.__values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
                                source = sources_1_1.value;
                                addSource({ source: source, pointer: pointer });
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return)) _a.call(sources_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    return [2 /*return*/];
            }
        });
    }); });
}
function collectFallbackSync(_a) {
    var queue = _a.queue, pointer = _a.pointer, options = _a.options, pointerOptions = _a.pointerOptions, addSource = _a.addSource;
    return queue(function () {
        var e_2, _a;
        var sources = loadFileSync(pointer, tslib.__assign(tslib.__assign({}, options), pointerOptions));
        if (sources) {
            try {
                for (var sources_2 = tslib.__values(sources), sources_2_1 = sources_2.next(); !sources_2_1.done; sources_2_1 = sources_2.next()) {
                    var source = sources_2_1.value;
                    addSource({ source: source, pointer: pointer });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (sources_2_1 && !sources_2_1.done && (_a = sources_2.return)) _a.call(sources_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    });
}

/**
 * @internal
 */
var filterKind = function (content, filterKinds) {
    var e_1, _a, e_2, _b;
    if (content && content.definitions && content.definitions.length && filterKinds && filterKinds.length > 0) {
        var invalidDefinitions = [];
        var validDefinitions = [];
        try {
            for (var _c = tslib.__values(content.definitions), _d = _c.next(); !_d.done; _d = _c.next()) {
                var definitionNode = _d.value;
                if (filterKinds.includes(definitionNode.kind)) {
                    invalidDefinitions.push(definitionNode);
                }
                else {
                    validDefinitions.push(definitionNode);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (invalidDefinitions.length > 0) {
            if (process.env['DEBUG']) {
                try {
                    for (var invalidDefinitions_1 = tslib.__values(invalidDefinitions), invalidDefinitions_1_1 = invalidDefinitions_1.next(); !invalidDefinitions_1_1.done; invalidDefinitions_1_1 = invalidDefinitions_1.next()) {
                        var d = invalidDefinitions_1_1.value;
                        console.log("Filtered document of kind " + d.kind + " due to filter policy (" + filterKinds.join(', ') + ")");
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (invalidDefinitions_1_1 && !invalidDefinitions_1_1.done && (_b = invalidDefinitions_1.return)) _b.call(invalidDefinitions_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        return {
            kind: graphql.Kind.DOCUMENT,
            definitions: validDefinitions,
        };
    }
    return content;
};

function parseSource(_a) {
    var partialSource = _a.partialSource, options = _a.options, pointerOptionMap = _a.pointerOptionMap, addValidSource = _a.addValidSource;
    if (partialSource) {
        var input = prepareInput({
            source: partialSource,
            options: options,
            pointerOptionMap: pointerOptionMap,
        });
        parseSchema(input);
        parseRawSDL(input);
        if (input.source.document) {
            useKindsFilter(input);
            useComments(input);
            collectValidSources(input, addValidSource);
        }
    }
}
//
function prepareInput(_a) {
    var source = _a.source, options = _a.options, pointerOptionMap = _a.pointerOptionMap;
    var specificOptions = tslib.__assign({}, options);
    if (source.location) {
        specificOptions = tslib.__assign(tslib.__assign({}, specificOptions), pointerOptionMap[source.location]);
    }
    return { source: tslib.__assign({}, source), options: specificOptions };
}
function parseSchema(input) {
    if (input.source.schema) {
        input.source.rawSDL = utils.printSchemaWithDirectives(input.source.schema, input.options);
    }
}
function parseRawSDL(input) {
    if (input.source.rawSDL) {
        input.source.document = utils.parseGraphQLSDL(input.source.location, input.source.rawSDL, input.options).document;
    }
}
function useKindsFilter(input) {
    if (input.options.filterKinds) {
        input.source.document = filterKind(input.source.document, input.options.filterKinds);
    }
}
function useComments(input) {
    if (!input.source.rawSDL && input.source.document) {
        input.source.rawSDL = utils.printWithComments(input.source.document);
        utils.resetComments();
    }
}
function collectValidSources(input, addValidSource) {
    var _a;
    if (((_a = input.source.document) === null || _a === void 0 ? void 0 : _a.definitions) && input.source.document.definitions.length > 0) {
        addValidSource(input.source);
    }
}

var CONCURRENCY_LIMIT$1 = 100;
/**
 * Asynchronously loads any GraphQL documents (i.e. executable documents like
 * operations and fragments as well as type system definitions) from the
 * provided pointers.
 * @param pointerOrPointers Pointers to the sources to load the documents from
 * @param options Additional options
 */
function loadTypedefs(pointerOrPointers, options) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var _a, ignore, pointerOptionMap, sources, validSources, limit;
        var _b;
        return tslib.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = normalizePointers(pointerOrPointers), ignore = _a.ignore, pointerOptionMap = _a.pointerOptionMap;
                    options.ignore = utils.asArray(options.ignore || []);
                    (_b = options.ignore).push.apply(_b, tslib.__spreadArray([], tslib.__read(ignore), false));
                    applyDefaultOptions(options);
                    return [4 /*yield*/, collectSources({
                            pointerOptionMap: pointerOptionMap,
                            options: options,
                        })];
                case 1:
                    sources = _c.sent();
                    validSources = [];
                    limit = useLimit(CONCURRENCY_LIMIT$1);
                    return [4 /*yield*/, Promise.all(sources.map(function (partialSource) {
                            return limit(function () {
                                return parseSource({
                                    partialSource: partialSource,
                                    options: options,
                                    pointerOptionMap: pointerOptionMap,
                                    addValidSource: function (source) {
                                        validSources.push(source);
                                    },
                                });
                            });
                        }))];
                case 2:
                    _c.sent();
                    return [2 /*return*/, prepareResult({ options: options, pointerOptionMap: pointerOptionMap, validSources: validSources })];
            }
        });
    });
}
/**
 * Synchronously loads any GraphQL documents (i.e. executable documents like
 * operations and fragments as well as type system definitions) from the
 * provided pointers.
 * @param pointerOrPointers Pointers to the sources to load the documents from
 * @param options Additional options
 */
function loadTypedefsSync(pointerOrPointers, options) {
    var e_1, _a;
    var _b = normalizePointers(pointerOrPointers), ignore = _b.ignore, pointerOptionMap = _b.pointerOptionMap;
    options.ignore = utils.asArray(options.ignore || []).concat(ignore);
    applyDefaultOptions(options);
    var sources = collectSourcesSync({
        pointerOptionMap: pointerOptionMap,
        options: options,
    });
    var validSources = [];
    try {
        for (var sources_1 = tslib.__values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
            var partialSource = sources_1_1.value;
            parseSource({
                partialSource: partialSource,
                options: options,
                pointerOptionMap: pointerOptionMap,
                addValidSource: function (source) {
                    validSources.push(source);
                },
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return)) _a.call(sources_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return prepareResult({ options: options, pointerOptionMap: pointerOptionMap, validSources: validSources });
}
//
function prepareResult(_a) {
    var options = _a.options, pointerOptionMap = _a.pointerOptionMap, validSources = _a.validSources;
    var pointerList = Object.keys(pointerOptionMap);
    if (pointerList.length > 0 && validSources.length === 0) {
        throw new Error("\n      Unable to find any GraphQL type definitions for the following pointers:\n        " + pointerList.map(function (p) { return "\n          - " + p + "\n          "; }));
    }
    return options.sort
        ? validSources.sort(function (left, right) { return utils.compareStrings(left.location, right.location); })
        : validSources;
}

/**
 * Kinds of AST nodes that are included in executable documents
 */
var OPERATION_KINDS = [graphql.Kind.OPERATION_DEFINITION, graphql.Kind.FRAGMENT_DEFINITION];
/**
 * Kinds of AST nodes that are included in type system definition documents
 */
var NON_OPERATION_KINDS = Object.keys(graphql.Kind)
    .reduce(function (prev, v) { return tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(prev), false), [graphql.Kind[v]], false); }, [])
    .filter(function (v) { return !OPERATION_KINDS.includes(v); });
/**
 * Asynchronously loads executable documents (i.e. operations and fragments) from
 * the provided pointers. The pointers may be individual files or a glob pattern.
 * The files themselves may be `.graphql` files or `.js` and `.ts` (in which
 * case they will be parsed using graphql-tag-pluck).
 * @param pointerOrPointers Pointers to the files to load the documents from
 * @param options Additional options
 */
function loadDocuments(pointerOrPointers, options) {
    return loadTypedefs(pointerOrPointers, tslib.__assign({ noRequire: true, filterKinds: NON_OPERATION_KINDS }, options));
}
/**
 * Synchronously loads executable documents (i.e. operations and fragments) from
 * the provided pointers. The pointers may be individual files or a glob pattern.
 * The files themselves may be `.graphql` files or `.js` and `.ts` (in which
 * case they will be parsed using graphql-tag-pluck).
 * @param pointerOrPointers Pointers to the files to load the documents from
 * @param options Additional options
 */
function loadDocumentsSync(pointerOrPointers, options) {
    return loadTypedefsSync(pointerOrPointers, tslib.__assign({ noRequire: true, filterKinds: NON_OPERATION_KINDS }, options));
}

/**
 * Asynchronously loads a schema from the provided pointers.
 * @param schemaPointers Pointers to the sources to load the schema from
 * @param options Additional options
 */
function loadSchema(schemaPointers, options) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var sources, _a, schemas, typeDefs, mergeSchemasOptions, schema$1;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadTypedefs(schemaPointers, tslib.__assign(tslib.__assign({}, options), { filterKinds: OPERATION_KINDS }))];
                case 1:
                    sources = _b.sent();
                    _a = collectSchemasAndTypeDefs(sources), schemas = _a.schemas, typeDefs = _a.typeDefs;
                    mergeSchemasOptions = tslib.__assign(tslib.__assign({}, options), { schemas: schemas, typeDefs: typeDefs });
                    schema$1 = schema.mergeSchemas(mergeSchemasOptions);
                    if (options === null || options === void 0 ? void 0 : options.includeSources) {
                        includeSources(schema$1, sources);
                    }
                    return [2 /*return*/, options.sort ? graphql.lexicographicSortSchema(schema$1) : schema$1];
            }
        });
    });
}
/**
 * Synchronously loads a schema from the provided pointers.
 * @param schemaPointers Pointers to the sources to load the schema from
 * @param options Additional options
 */
function loadSchemaSync(schemaPointers, options) {
    var sources = loadTypedefsSync(schemaPointers, tslib.__assign({ filterKinds: OPERATION_KINDS }, options));
    var _a = collectSchemasAndTypeDefs(sources), schemas = _a.schemas, typeDefs = _a.typeDefs;
    var schema$1 = schema.mergeSchemas(tslib.__assign({ schemas: schemas, typeDefs: typeDefs }, options));
    if (options === null || options === void 0 ? void 0 : options.includeSources) {
        includeSources(schema$1, sources);
    }
    return options.sort ? graphql.lexicographicSortSchema(schema$1) : schema$1;
}
function includeSources(schema, sources) {
    var e_1, _a;
    var finalSources = [];
    try {
        for (var sources_1 = tslib.__values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
            var source = sources_1_1.value;
            if (source.rawSDL) {
                finalSources.push(new graphql.Source(source.rawSDL, source.location));
            }
            else if (source.document) {
                finalSources.push(new graphql.Source(graphql.print(source.document), source.location));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return)) _a.call(sources_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    schema.extensions = tslib.__assign(tslib.__assign({}, schema.extensions), { sources: finalSources, extendedSources: sources });
}
function collectSchemasAndTypeDefs(sources) {
    var e_2, _a;
    var schemas = [];
    var typeDefs = [];
    try {
        for (var sources_2 = tslib.__values(sources), sources_2_1 = sources_2.next(); !sources_2_1.done; sources_2_1 = sources_2.next()) {
            var source = sources_2_1.value;
            if (source.schema) {
                schemas.push(source.schema);
            }
            else if (source.document) {
                typeDefs.push(source.document);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (sources_2_1 && !sources_2_1.done && (_a = sources_2.return)) _a.call(sources_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return {
        schemas: schemas,
        typeDefs: typeDefs,
    };
}

exports.NON_OPERATION_KINDS = NON_OPERATION_KINDS;
exports.OPERATION_KINDS = OPERATION_KINDS;
exports.filterKind = filterKind;
exports.loadDocuments = loadDocuments;
exports.loadDocumentsSync = loadDocumentsSync;
exports.loadSchema = loadSchema;
exports.loadSchemaSync = loadSchemaSync;
exports.loadTypedefs = loadTypedefs;
exports.loadTypedefsSync = loadTypedefsSync;
